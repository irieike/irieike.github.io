<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>RUDEBOY — Space Field (Frogs)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    .hint{
      position:fixed;left:12px;bottom:12px;color:#bbb;
      font:12px system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;opacity:.9
    }
    .hint b{color:#fff}
  </style>

  <!-- Import map for CDN modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="hint">
    Click a distant frog to fly to it • <b>R</b> autorotate • <b>B</b> bloom • <b>F</b> fly mode (WASD, drag-to-look)
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import { FlyControls } from "three/examples/jsm/controls/FlyControls.js";
    import { RoomEnvironment } from "three/examples/jsm/environments/RoomEnvironment.js";
    import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
    import { SkeletonUtils } from "three/examples/jsm/utils/SkeletonUtils.js";

    // --- Renderer ---
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    // --- Scene / Camera ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(0, 0.6, 10);

    // --- Environment reflections (no HDR files) ---
    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;

    // --- Lights (subtle; env does most of the work) ---
    const key = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set(5,6,4); scene.add(key);
    const rim = new THREE.DirectionalLight(0xff6a00, 0.6); rim.position.set(-6,2,-4); scene.add(rim);
    const back = new THREE.DirectionalLight(0x88aaff, 0.4); back.position.set(0,-2,-4); scene.add(back);

    // --- Starfield backdrop ---
    (function makeStars(){
      const N = 2000, R = 160;
      const pos = new Float32Array(N*3);
      for (let i=0;i<N;i++){
        const u=Math.random(), v=Math.random();
        const th=2*Math.PI*u, ph=Math.acos(2*v-1);
        pos[i*3+0]=R*Math.sin(ph)*Math.cos(th);
        pos[i*3+1]=R*Math.sin(ph)*Math.sin(th);
        pos[i*3+2]=R*Math.cos(ph);
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(pos,3));
      const mat = new THREE.PointsMaterial({ size:0.65, sizeAttenuation:true, color:0x9aa3ff, transparent:true, opacity:0.8 });
      scene.add(new THREE.Points(geo, mat));
    })();

    // --- Sun/Moon in the far background ---
    let celestial;
    (function addCelestialBody(){
      const hour = new Date().getHours();
      const isDay = hour >= 6 && hour < 18;
      const geometry = new THREE.SphereGeometry(6, 64, 64);
      const material = isDay
        ? new THREE.MeshStandardMaterial({ emissive:0xffaa33, emissiveIntensity:1.5, color:0xffffaa, metalness:0.1, roughness:0.5 })
        : new THREE.MeshStandardMaterial({ emissive:0xcccccc, emissiveIntensity:0.3, color:0xffffff, metalness:0.0, roughness:1.0 });
      celestial = new THREE.Mesh(geometry, material);
      celestial.position.set(-50, 30, -100);
      scene.add(celestial);
    })();

    // --- Postprocessing (bloom, starts OFF) ---
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.05, 0.6, 0.12);
    composer.addPass(bloom);
    bloom.strength = 0; // keep bloom but disable at start

    // --- Controls ---
    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.enableDamping = true;
    orbit.enablePan = false;
    orbit.autoRotate = true;
    orbit.autoRotateSpeed = 0.45;
    orbit.minDistance = 4;
    orbit.maxDistance = 100;

    const fly = new FlyControls(camera, renderer.domElement);
    fly.enabled = false;          // off by default
    fly.movementSpeed = 10;       // WASD speed
    fly.rollSpeed = 0.8;          // QE speed
    fly.dragToLook = true;        // hold mouse to look
    fly.autoForward = false;

    function useOrbitMode(on){
      orbit.enabled = on;
      fly.enabled = !on;
    }
    useOrbitMode(true);

    // --- Frog bubble factory ---
    const bubbleRadius = 1.2;
    function makeBubbleMaterial(){
      return new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        metalness: 0.0,
        roughness: 0.02,
        transmission: 1.0,
        thickness: 0.18,
        ior: 1.33,
        clearcoat: 1.0,
        clearcoatRoughness: 0.02,
        envMapIntensity: 1.0,
        transparent: true,
        opacity: 1.0,
        side: THREE.DoubleSide,
        iridescence: 1.0,
        iridescenceIOR: 1.3,
        iridescenceThicknessRange: [80, 450]
      });
    }

    const gltfLoader = new GLTFLoader();
    const frogUrl = "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Fox/glTF-Binary/Fox.glb"; // TODO: swap with frog GLB

    async function loadFrogOnce(){
      return new Promise((resolve, reject)=>{
        gltfLoader.load(frogUrl, (gltf)=>{
          resolve(gltf.scene);
        }, undefined, reject);
      });
    }

    let baseFrog = null;
    function createFrogBubbleInstance(){
      const group = new THREE.Group();

      // bubble shell
      const bubble = new THREE.Mesh(new THREE.SphereGeometry(bubbleRadius, 96, 64), makeBubbleMaterial());
      group.add(bubble);

      // clone frog
      const frog = SkeletonUtils.clone(baseFrog);

      // fit frog into bubble
      const box = new THREE.Box3().setFromObject(frog);
      const size = new THREE.Vector3(); box.getSize(size);
      const maxDim = Math.max(size.x, size.y, size.z) || 1;
      const target = bubbleRadius * 1.25; // margin from shell
      const s = target / maxDim;
      frog.scale.setScalar(s);
      frog.position.set(0, -0.35, 0);
      frog.rotation.y = Math.PI * (Math.random()*0.6 - 0.3);
      group.add(frog);

      return group;
    }

    // --- FROGS array and clickables ---
    const FROGS = [];
    const clickables = [];

    // Build frogs after model loads
    (async function buildFrogs(){
      baseFrog = await loadFrogOnce();

      // HERO at origin
      const hero = createFrogBubbleInstance();
      hero.rotation.x = THREE.MathUtils.degToRad(-6);
      scene.add(hero);
      FROGS.push(hero); clickables.push(hero);

      // distant copies
      const copies = 24, minR = 35, maxR = 120;
      for (let i=0;i<copies;i++){
        const g = createFrogBubbleInstance();
        const u=Math.random(), v=Math.random();
        const theta=2*Math.PI*u, phi=Math.acos(2*v-1);
        const r = THREE.MathUtils.lerp(minR, maxR, Math.random());
        g.position.set(
          r*Math.sin(phi)*Math.cos(theta),
          r*Math.sin(phi)*Math.sin(theta),
          r*Math.cos(phi)
        );
        g.rotation.set(
          THREE.MathUtils.degToRad(-6 + (Math.random()-0.5)*10),
          Math.random()*Math.PI*2,
          (Math.random()-0.5)*0.2
        );
        g.scale.setScalar(THREE.MathUtils.lerp(0.8, 1.6, Math.random()));
        scene.add(g);
        FROGS.push(g); clickables.push(g);
      }

      start();
    })();

    // --- Raycast click to fly-to ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    function onClickFly(e){
      mouse.x = (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(clickables, true);
      if (!hits.length) return;
      // find the top-level frog group
      let obj = hits[0].object;
      while (obj && !FROGS.includes(obj) && obj.parent) obj = obj.parent;
      const target = obj.position.clone();
      flyTo(target, 1200);
    }
    addEventListener("click", onClickFly);

    // --- Smooth camera flight (for Orbit mode) ---
    let camTween = null;
    function flyTo(targetPos, duration=1200){
      if (fly.enabled){
        const dir = targetPos.clone().sub(camera.position).normalize();
        camera.position.add(dir.multiplyScalar(5));
        return;
      }
      const startCam = camera.position.clone();
      const startTar = orbit.target.clone();
      const finalDist = 8;
      const dir = targetPos.clone().sub(startCam).normalize();
      const endTar = targetPos.clone();
      const endCam = targetPos.clone().add(dir.multiplyScalar(-finalDist));

      const start = performance.now();
      const ease = (t)=> t<0.5 ? 2*t*t : -1+(4-2*t)*t;
      camTween = function step(now){
        const p = Math.min(1, (now - start) / duration);
        const k = ease(p);
        camera.position.lerpVectors(startCam, endCam, k);
        orbit.target.lerpVectors(startTar, endTar, k);
        if (p < 1 && camTween) requestAnimationFrame(camTween);
        else camTween = null;
      };
      requestAnimationFrame(camTween);
    }

    // --- Animation / render ---
    const clock = new THREE.Clock();
    let started = false;
    function start(){
      if (started) return; started = true;
      renderer.setAnimationLoop(() => {
        const dt = clock.getDelta();

        for (let i=0;i<FROGS.length;i++){
          const g = FROGS[i];
          g.rotation.y += (i===0 ? 0.12 : 0.02) * dt;
          g.position.y += Math.sin((clock.elapsedTime + i)*0.7) * 0.0008; // subtle float
        }

        if (celestial) celestial.rotation.y += 0.005;

        if (orbit.enabled) orbit.update();
        if (fly.enabled)   fly.update(dt);

        composer.render();
      });
    }

    // --- Resize ---
    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
    });

    // --- Hotkeys ---
    addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      if (k === "r") orbit.autoRotate = !orbit.autoRotate;
      if (k === "b") bloom.strength   = bloom.strength > 0 ? 0 : 1.05;
      if (k === "f") useOrbitMode(!fly.enabled);
    });
  </script>
</body>
</html>