<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>RUDEBOY — Title + Spherical Nav</title>
<link rel="preconnect" href="https://unpkg.com" crossorigin>
<link rel="preconnect" href="https://s3-us-west-2.amazonaws.com" crossorigin>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  .ui{position:fixed;left:12px;bottom:12px;color:#bbb;font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;opacity:.9}
  .ui b{color:#fff}
  .badge{position:fixed;right:12px;top:12px;color:#ddd;background:#111a;border:1px solid #333;padding:6px 10px;border-radius:10px;font:12px/1.2 system-ui;backdrop-filter: blur(4px);display:flex;gap:8px;align-items:center;z-index:10}
  .badge button{all:unset;cursor:pointer;font-weight:600;color:#fff}
  .help{position:fixed;left:12px;top:12px;background:#111e;border:1px solid #333;padding:10px 12px;border-radius:10px;color:#ddd;font:12px/1.4 system-ui;display:none;max-width:64ch;backdrop-filter: blur(4px);z-index:10}
  .help kbd{background:#222;border:1px solid #444;border-bottom-color:#333;border-radius:4px;padding:1px 4px;font:11px/1.2 monospace;color:#fff}
  .dot{width:6px;height:6px;border-radius:50%;background:#f6a;display:inline-block;box-shadow:0 0 10px #f6a}
</style>

<!-- Import map for CDN modules -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
  <div class="badge" id="badge">
    <span id="skyLabel">Sky: —</span>
    <span id="loadDot" class="dot"></span>
    <button id="btnFull">Full</button>
    <button id="btnBloom">Bloom</button>
    <button id="btnAuto">Auto</button>
    <button id="btnQual">Q</button>
    <button id="btnHelp">?</button>
  </div>
  <div class="help" id="helpBox">
    <div><b>Controls</b></div>
    <div>• Drag to orbit • Scroll to zoom</div>
    <div>• <kbd>F</kbd> Fullscreen • <kbd>O</kbd> Autorotate • <kbd>B</kbd> Bloom • <kbd>Q</kbd> Quality • <kbd>H</kbd> Help</div>
  </div>
  <div class="ui">Time-based sky • <b>Sun/Moon</b> rises by your local time</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { RoomEnvironment } from "three/examples/jsm/environments/RoomEnvironment.js";
import { FontLoader } from "three/examples/jsm/loaders/FontLoader.js";
import { TextGeometry } from "three/examples/jsm/geometries/TextGeometry.js";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
import { TTFLoader } from "three/examples/jsm/loaders/TTFLoader.js";

/* ----------------- Renderer (fast first pixel) ----------------- */
const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
renderer.setPixelRatio(1);
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.appendChild(renderer.domElement);

/* ----------------- Scene / Camera / Controls ----------------- */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 3000);
camera.position.set(0, 0.6, 10);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.autoRotate = true;

// Mobile detection for spacing/perf tweaks
const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
controls.autoRotateSpeed = 0.5;
controls.minDistance = 4;
controls.maxDistance = 100;

/* ----------------- Env / Lights ----------------- */
const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;

const key = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set(5,6,4); scene.add(key);
const rim = new THREE.DirectionalLight(0xff6a00, 0.6); rim.position.set(-6,2,-4); scene.add(rim);
scene.add(new THREE.AmbientLight(0xffffff, 0.15));

/* ----------------- PostFX (bloom off by default) ----------------- */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.0, 0.6, 0.1);
composer.addPass(bloom);

/* ----------------- Stars (progressive) ----------------- */
const starGroup = new THREE.Group(); scene.add(starGroup);
function addStars(count, radius){
  const pos = new Float32Array(count*3);
  for (let i=0;i<count;i++){
    const u=Math.random(), v=Math.random();
    const th=2*Math.PI*u, ph=Math.acos(2*v-1);
    pos[3*i+0]=radius*Math.sin(ph)*Math.cos(th);
    pos[3*i+1]=radius*Math.sin(ph)*Math.sin(th);
    pos[3*i+2]=radius*Math.cos(ph);
  }
  const g=new THREE.BufferGeometry(); g.setAttribute("position", new THREE.BufferAttribute(pos,3));
  const m=new THREE.PointsMaterial({ size:0.7, sizeAttenuation:true, color:0x9aa3ff, transparent:true, opacity:0.7 });
  starGroup.add(new THREE.Points(g,m));
}
addStars(500, 180);
setTimeout(()=>addStars(1200, 220), 120);
setTimeout(()=>addStars(1800, 260), 240);

// Add occasional shooting stars
const shootingGroup = new THREE.Group(); scene.add(shootingGroup);
function spawnShootingStar(){
  const g = new THREE.BufferGeometry();
  const positions = new Float32Array(2*3);
  const x = (Math.random()-0.5)*140;
  const y = Math.random()*60 + 10;
  const z = -120 - Math.random()*60;
  positions.set([x,y,z, x-3-Math.random()*3, y-1.5-Math.random()*2, z]);
  g.setAttribute('position', new THREE.BufferAttribute(positions,3));
  const m = new THREE.LineBasicMaterial({ color: 0x9aa3ff, transparent:true, opacity:0.5 });
  const line = new THREE.Line(g, m);
  shootingGroup.add(line);
  setTimeout(()=>{ shootingGroup.remove(line); g.dispose(); }, 1200);
}
setInterval(()=>{ if (!document.hidden) spawnShootingStar(); }, 900);

// Faint nebulae and planet billboards
const deepSpaceGroup = new THREE.Group(); scene.add(deepSpaceGroup);
function makeCircleTexture(innerColor, outerColor){
  const s = 256; const c = document.createElement('canvas'); c.width=c.height=s;
  const ctx = c.getContext('2d');
  const g = ctx.createRadialGradient(s/2,s/2,10, s/2,s/2,s/2);
  g.addColorStop(0, innerColor);
  g.addColorStop(1, outerColor);
  ctx.fillStyle = g; ctx.fillRect(0,0,s,s);
  return new THREE.CanvasTexture(c);
}
function addNebulaBillboard(colorInner, colorOuter, position, scale, opacity){
  const tex = makeCircleTexture(colorInner, colorOuter);
  tex.colorSpace = THREE.SRGBColorSpace;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, opacity, depthWrite:false });
  const spr = new THREE.Sprite(mat); spr.position.copy(position); spr.scale.setScalar(scale); spr.renderOrder = -1000;
  deepSpaceGroup.add(spr);
}
// add a few faint auras
addNebulaBillboard('#4444ff', 'rgba(0,0,64,0)', new THREE.Vector3(-60, 20, -220), 60, 0.18);
addNebulaBillboard('#ff44aa', 'rgba(64,0,32,0)', new THREE.Vector3(70, -10, -260), 80, 0.14);
addNebulaBillboard('#44ffaa', 'rgba(0,64,32,0)', new THREE.Vector3(10, 40, -300), 90, 0.12);

/* ----------------- Sun/Moon time-based ----------------- */
const skyLabel = document.getElementById("skyLabel");
const skyGroup = new THREE.Group(); scene.add(skyGroup);

// Sun and subtle corona remain
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(26, 64, 48),
  new THREE.MeshPhysicalMaterial({
    color: 0xffffff, emissive: 0xffb347, emissiveIntensity: 3.2,
    metalness: 0.0, roughness: 0.55, clearcoat: 0.4, clearcoatRoughness: 0.4
  })
);
sun.position.set(0,0,-150); skyGroup.add(sun);

const corona = new THREE.Mesh(
  new THREE.SphereGeometry(28.5, 48, 36),
  new THREE.MeshBasicMaterial({ color: 0xffb347, transparent:true, opacity:0.25, depthWrite:false, blending:THREE.AdditiveBlending })
);
corona.position.copy(sun.position); skyGroup.add(corona);

// Replace moon with detailed Phong-based version and starfield world backdrop
let moon, world;
{
  const textureURL = "https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/lroc_color_poles_1k.jpg";
  const displacementURL = "https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/ldem_3_8bit.jpg";
  const worldURL = "https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/hipp8_s.jpg";
  const textureLoader = new THREE.TextureLoader();
  const texture = textureLoader.load(textureURL);
  const displacementMap = textureLoader.load(displacementURL);
  const worldTexture = textureLoader.load(worldURL);

  const moonGeo = new THREE.SphereGeometry(16, 60, 60);
  const moonMat = new THREE.MeshPhongMaterial({
    color: 0xffffff,
    map: texture,
    displacementMap: displacementMap,
    displacementScale: 0.9,
    bumpMap: displacementMap,
    bumpScale: 0.6,
    reflectivity: 0,
    shininess: 0
  });
  moon = new THREE.Mesh(moonGeo, moonMat);
  moon.position.set(0,0,-150);
  skyGroup.add(moon);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
  dirLight.position.set(-100, 10, 50);
  skyGroup.add(dirLight);

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.12);
  hemiLight.color.setHSL(0.6, 1, 0.6);
  hemiLight.groundColor.setHSL(0.095, 1, 0.75);
  hemiLight.position.set(0, 0, 0);
  skyGroup.add(hemiLight);

  const worldGeo = new THREE.SphereGeometry(1000, 60, 60);
  const worldMat = new THREE.MeshBasicMaterial({ color: 0xffffff, map: worldTexture, side: THREE.BackSide });
  world = new THREE.Mesh(worldGeo, worldMat);
  world.position.set(0,0,-150);
  skyGroup.add(world);
}

function updateSkyByTime(){
  const now = new Date();
  const hrs = now.getHours() + now.getMinutes()/60;
  const daytime = (hrs >= 6 && hrs < 18);
  const alt = Math.sin((hrs/24)*Math.PI*2 - Math.PI/2);
  const y = THREE.MathUtils.lerp(-40, 40, (alt+1)/2);
  const x = Math.cos((hrs/24)*Math.PI*2) * 20;
  sun.visible = corona.visible = daytime;
  moon.visible = !daytime;
  if (daytime){ sun.position.set(x,y,-150); corona.position.set(x,y,-150); skyLabel.textContent = "Sky: Sun"; }
  else { moon.position.set(x,y,-150); skyLabel.textContent = "Sky: Moon"; }
  sun.rotation.y += 0.004; if (moon) { moon.rotation.y += 0.002; moon.rotation.x += 0.0001; } if (world) { world.rotation.y += 0.0001; world.rotation.x += 0.0005; }
}

/* ----------------- RUDEBOY Title ----------------- */
const placeholder = new THREE.Mesh(
  new THREE.TorusKnotGeometry(0.9, 0.28, 100, 16),
  new THREE.MeshPhysicalMaterial({
    color: 0xff4300, metalness: 0.7, roughness: 0.35, clearcoat: 1.0, clearcoatRoughness: 0.2, envMapIntensity: 1.2,
    emissive: 0x5a1c00, emissiveIntensity: 0.2
  })
);
placeholder.position.y = 0.9;
scene.add(placeholder);

let textMesh = null;
const fontLoader = new FontLoader();
// const fontUrl = "https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json";

// Load local TTF and parse to a three.js Font (with fallback)
const ttfLoader = new TTFLoader();
const fontPath = encodeURI("./New York Hardcore.ttf");
ttfLoader.load(fontPath, (ttfJson)=>{
  console.log("Loaded local TTF font:", fontPath);
  const font = fontLoader.parse(ttfJson);

  const midGeo = new TextGeometry("RUDEBOY", {
    font, size: 1.6, height: 0.34,
    curveSegments: 8, bevelEnabled: true,
    bevelThickness: 0.05, bevelSize: 0.045, bevelSegments: 3
  });
  midGeo.computeBoundingBox(); midGeo.center();

  const mat = new THREE.MeshPhysicalMaterial({
    color: 0xff4300, metalness: 0.9, roughness: 0.25, clearcoat: 1.0, clearcoatRoughness: 0.15,
    emissive: 0x9b2d00, emissiveIntensity: 0.25, envMapIntensity: 1.2
  });

  // Replace single-mesh title with per-letter colored meshes (R,G,Y pattern with Y ending red)
  const title = "RUDEBOY";
  const colors = [0xff0000, 0xffd700, 0x00a000]; // red, gold, green
  const letters = [];
  const tempMat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff, metalness: 0.9, roughness: 0.25, clearcoat: 1.0, clearcoatRoughness: 0.15,
    emissive: 0x111111, emissiveIntensity: 0.25, envMapIntensity: 1.2
  });

  // Compute per-letter geometries and layout
  const shapes = font.generateShapes(title, 1.6, 8);
  const fullGeo = new THREE.ShapeGeometry(shapes);
  fullGeo.computeBoundingBox();
    const fullWidth = (fullGeo.boundingBox.max.x - fullGeo.boundingBox.min.x);
  const letterSpacing = isMobile ? 0.22 : 0.15;
 
  let cursorX = -fullWidth/2;
  for (let i=0;i<title.length;i++){
    const ch = title[i];
    const chShapes = font.generateShapes(ch, 1.6, 8);
    const chGeo2D = new THREE.ShapeGeometry(chShapes);
    chGeo2D.computeBoundingBox();
    const chWidth = (chGeo2D.boundingBox.max.x - chGeo2D.boundingBox.min.x);

    const chGeo3D = new TextGeometry(ch, {
      font, size: 1.6, height: 0.34,
      curveSegments: 8, bevelEnabled: true,
      bevelThickness: 0.05, bevelSize: 0.045, bevelSegments: 3
    });
    chGeo3D.computeBoundingBox();

    const colorIndex = (i < title.length-1) ? (i % 3) : 0; // last 'Y' forced red (index 0)
    const matLetter = tempMat.clone();
    matLetter.color = new THREE.Color(colors[colorIndex]);
    matLetter.emissive = new THREE.Color(colors[colorIndex]).multiplyScalar(0.18);

    const mesh = new THREE.Mesh(chGeo3D, matLetter);
    const offsetX = cursorX - chGeo2D.boundingBox.min.x;
    mesh.position.x = offsetX;
    mesh.rotation.x = THREE.MathUtils.degToRad(-8);
    scene.add(mesh);
    letters.push(mesh);

    cursorX += chWidth + letterSpacing;
  }

  // Provide a group so downstream code still animates the title
  textMesh = new THREE.Group();
  for (const m of letters) textMesh.add(m);
  scene.add(textMesh);

  // remove placeholder once text rendered
  setTimeout(()=>{ scene.remove(placeholder); placeholder.geometry.dispose(); }, 100);

  // upgrade geometry when idle (rebuild per-letter with higher segments)
  requestIdleCallback?.(()=>{
    const title = "RUDEBOY";
    const newLetters = [];
    let cursorX = 0;
    // recompute centered layout
    const shapes = font.generateShapes(title, 1.6, 10);
    const fullGeo = new THREE.ShapeGeometry(shapes); fullGeo.computeBoundingBox();
    const fullWidth = (fullGeo.boundingBox.max.x - fullGeo.boundingBox.min.x);
    const letterSpacing = isMobile ? 0.22 : 0.15;
    cursorX = -fullWidth/2;
    // remove old children
    while (textMesh.children.length) textMesh.remove(textMesh.children[0]);
    for (let i=0;i<title.length;i++){
      const ch = title[i];
      const chShapes = font.generateShapes(ch, 1.6, 10);
      const chGeo2D = new THREE.ShapeGeometry(chShapes); chGeo2D.computeBoundingBox();
      const chWidth = (chGeo2D.boundingBox.max.x - chGeo2D.boundingBox.min.x);
      const chGeo3D = new TextGeometry(ch, { font, size:1.6, height:0.38, curveSegments:10, bevelEnabled:true, bevelThickness:0.06, bevelSize:0.05, bevelSegments:4 });
      const colorIndex = (i < title.length-1) ? (i % 3) : 0;
      const matLetter = new THREE.MeshPhysicalMaterial({ color: new THREE.Color([0xff0000,0xffd700,0x00a000][colorIndex]), metalness:0.9, roughness:0.25, clearcoat:1.0, clearcoatRoughness:0.15, emissive: new THREE.Color([0xff0000,0xffd700,0x00a000][colorIndex]).multiplyScalar(0.18), envMapIntensity:1.2 });
      const mesh = new THREE.Mesh(chGeo3D, matLetter);
      const offsetX = cursorX - chGeo2D.boundingBox.min.x; mesh.position.x = offsetX; mesh.rotation.x = THREE.MathUtils.degToRad(-8);
      textMesh.add(mesh);
      cursorX += chWidth + letterSpacing;
    }
  });

  postFirstFrameUpgrades();
}, undefined, (err)=>{
  console.error("Failed to load TTF font:", err);
  // Fallback to a visibly different JSON font so the change is obvious
  fontLoader.load("https://unpkg.com/three@0.160.0/examples/fonts/gentilis_bold.typeface.json", (jsonFont)=>{
    const midGeo = new TextGeometry("RUDEBOY", {
      font: jsonFont, size: 1.6, height: 0.34,
      curveSegments: 8, bevelEnabled: true,
      bevelThickness: 0.05, bevelSize: 0.045, bevelSegments: 3
    });
    midGeo.computeBoundingBox(); midGeo.center();

    const mat = new THREE.MeshPhysicalMaterial({
      color: 0xff4300, metalness: 0.9, roughness: 0.25, clearcoat: 1.0, clearcoatRoughness: 0.15,
      emissive: 0x9b2d00, emissiveIntensity: 0.25, envMapIntensity: 1.2
    });

    // Fallback path: single-mesh title without glow to avoid iOS double render
    textMesh = new THREE.Mesh(midGeo, mat);
    textMesh.rotation.x = THREE.MathUtils.degToRad(-8);
    scene.add(textMesh);

    setTimeout(()=>{ scene.remove(placeholder); placeholder.geometry.dispose(); }, 100);

    requestIdleCallback?.(()=>{
      const hiGeo = new TextGeometry("RUDEBOY", {
        font: jsonFont, size: 1.6, height: 0.38,
        curveSegments: 10, bevelEnabled: true, bevelThickness: 0.06, bevelSize: 0.05, bevelSegments: 4
      });
      hiGeo.computeBoundingBox(); hiGeo.center();
      textMesh.geometry.dispose();
      textMesh.geometry = hiGeo;
    });

    postFirstFrameUpgrades();
  });
});

/* ----------------- NAV: Spinning Sphere Buttons (always readable text) ----------------- */
const navGroup = new THREE.Group();
scene.add(navGroup);

// BIGGER label sprites
function makeLabelSprite(text){
  const scale = 2, pad = 28*scale;
  const fontPx = 96 * scale; // ← was 64 * scale

  const cvs = document.createElement('canvas');
  const ctx = cvs.getContext('2d');
  ctx.font = `800 ${fontPx}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
  const w = Math.ceil(ctx.measureText(text).width + pad*2);
  const h = Math.ceil(fontPx + pad*2);
  cvs.width = w; cvs.height = h;

  // dark plate
  if (ctx.roundRect){
    ctx.fillStyle = 'rgba(0,0,0,0.78)';
    ctx.beginPath(); ctx.roundRect(8*scale,8*scale, w-16*scale, h-16*scale, 18*scale); ctx.fill();
  } else {
    ctx.fillStyle = 'rgba(0,0,0,0.78)'; ctx.fillRect(8*scale,8*scale, w-16*scale, h-16*scale);
  }
  // outlined white text
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.font = `800 ${fontPx}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
  ctx.lineWidth = 10*scale; ctx.strokeStyle='rgba(0,0,0,0.92)';
  ctx.strokeText(text, w/2, h/2 + 2*scale);
  ctx.fillStyle='#fff'; ctx.fillText(text, w/2, h/2 + 2*scale);

  const tex = new THREE.CanvasTexture(cvs);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 1;

  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthTest:false, depthWrite:false });
  const sprite = new THREE.Sprite(mat);

  // show larger in scene (was /480)
  sprite.scale.set(w/(360*scale), h/(360*scale), 1);
  sprite.renderOrder = 999;
  return sprite;
}

// build one spherical nav button
function makeNavSphere({label, url, color, position}){
  const group = new THREE.Group();
  group.position.copy(position);

  const sphere = new THREE.Mesh(
    new THREE.SphereGeometry(0.75, 48, 32),
    new THREE.MeshPhysicalMaterial({
      color, metalness: 0.9, roughness: 0.25,
      clearcoat: 1.0, clearcoatRoughness: 0.15,
      envMapIntensity: 1.1,
      emissive: new THREE.Color(color).multiplyScalar(0.25)
    })
  );
  group.add(sphere);

  // subtle halo
  const halo = new THREE.Mesh(
    new THREE.SphereGeometry(0.92, 24, 16),
    new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.08, depthWrite:false, blending:THREE.AdditiveBlending })
  );
  group.add(halo);

  // label that always faces the camera (sprite)
  const labelSprite = makeLabelSprite(label.toUpperCase());
  labelSprite.position.set(0, 1.15, 0); // ← lifted slightly (was 1.05)
  group.add(labelSprite);

  // interaction data
  group.userData = { url, hover:false, t: Math.random()*Math.PI*2, sphere, label: labelSprite };
  navGroup.add(group);
  return group;
}

// layout: arc near the bottom
const yNav = -1.8, R = 3.2;
const navItems = [
  { label:'Shop',    url:'shop.html',    color:0xff6a6a, pos:new THREE.Vector3(-R, yNav,  1.2) },
  { label:'Projects',url:'project.html', color:0x66d1ff, pos:new THREE.Vector3(-1.0, yNav,  1.6) },
  { label:'Doodle',  url:'doodle.html',  color:0xc38bff, pos:new THREE.Vector3( 1.0, yNav,  1.6) },
  { label:'Contact', url:'contact.html', color:0xffc04d, pos:new THREE.Vector3( R,  yNav,  1.2) },
];
const navSpheres = navItems.map(i => makeNavSphere({label:i.label, url:i.url, color:i.color, position:i.pos}));

// raycast interactivity
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
function onPointerMove(e){
  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
}
function onClick(){
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(navGroup.children, true);
  if (!hits.length) return;
  // find the top-level nav group hit
  let g = hits[0].object;
  while (g && g.parent !== navGroup) g = g.parent;
  if (g && g.userData?.url){
    g.scale.set(1.15,1.15,1.15);
    setTimeout(()=>{ window.location.href = g.userData.url; }, 120);
  }
}
addEventListener('pointermove', onPointerMove, { passive:true });
addEventListener('click', onClick);
addEventListener('dblclick', ()=>{
  // double left-click: trigger nearest nav group
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(navGroup.children, true);
  if (hits.length){
    let g = hits[0].object; while (g && g.parent !== navGroup) g = g.parent;
    if (g && g.userData?.url){
      g.scale.set(1.15,1.15,1.15);
      setTimeout(()=>{ window.location.href = g.userData.url; }, 120);
    }
  }
});

/* ----------------- Cute floating frog bubble ----------------- */
const frogGroup = new THREE.Group(); scene.add(frogGroup);
function makeFrogBubbleTexture(){
  const s = 256; const c = document.createElement('canvas'); c.width = c.height = s; const ctx = c.getContext('2d');
  // bubble background
  const bg = ctx.createRadialGradient(s*0.5, s*0.45, s*0.2, s*0.5, s*0.5, s*0.48);
  bg.addColorStop(0, 'rgba(180,220,255,0.5)');
  bg.addColorStop(1, 'rgba(120,160,220,0.2)');
  ctx.fillStyle = bg; ctx.beginPath(); ctx.arc(s/2, s/2, s*0.48, 0, Math.PI*2); ctx.fill();
  ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(255,255,255,0.55)'; ctx.stroke();
  // simple Keroppi-like face
  function circle(x,y,r,fill){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=fill; ctx.fill(); }
  function ellipse(x,y,rx,ry,fill){ ctx.beginPath(); ctx.ellipse(x,y,rx,ry,0,0,Math.PI*2); ctx.fillStyle=fill; ctx.fill(); }
  // head
  circle(s*0.5, s*0.6, s*0.22, '#53d36b');
  // eyes
  circle(s*0.44, s*0.47, s*0.08, '#ffffff'); circle(s*0.56, s*0.47, s*0.08, '#ffffff');
  circle(s*0.44, s*0.47, s*0.03, '#333333'); circle(s*0.56, s*0.47, s*0.03, '#333333');
  // rosy cheeks
  ellipse(s*0.40, s*0.59, s*0.045, s*0.025, 'rgba(255,100,120,0.6)');
  ellipse(s*0.60, s*0.59, s*0.045, s*0.025, 'rgba(255,100,120,0.6)');
  // smile
  ctx.lineWidth = 3; ctx.strokeStyle = '#1f4d2b';
  ctx.beginPath(); ctx.arc(s*0.5, s*0.62, s*0.06, 0, Math.PI); ctx.stroke();
  return new THREE.CanvasTexture(c);
}
function spawnFrogBubble(){
  // safe spawn near title/nav without overlapping: pick from a few offsets
  const candidatePositions = [ new THREE.Vector3(-2.2, 1.2, 0), new THREE.Vector3(0, 1.3, 0.2), new THREE.Vector3(2.2, 1.2, 0) ];
  const pos = candidatePositions[Math.floor(Math.random()*candidatePositions.length)].clone();
  const tex = makeFrogBubbleTexture(); tex.colorSpace = THREE.SRGBColorSpace;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false });
  const spr = new THREE.Sprite(mat);
  spr.position.copy(pos); spr.scale.set(0.9,0.9,0.9);
  spr.userData = { t: 0, drift: new THREE.Vector3((Math.random()-0.5)*0.4, 0.5 + Math.random()*0.4, (Math.random()-0.5)*0.4) };
  frogGroup.add(spr);
  setTimeout(()=>{ frogGroup.remove(spr); tex.dispose(); }, 15000);
}
// spawn one initially
spawnFrogBubble();
// then occasionally
setInterval(()=>{ if (!document.hidden && frogGroup.children.length < 3) spawnFrogBubble(); }, 6000);

/* ----------------- Quality/Bloom + UI ----------------- */
let highQuality = false;
function setQuality(hq){
  highQuality = hq;
  renderer.setPixelRatio(hq ? Math.min(devicePixelRatio,2) : 1);
  renderer.toneMappingExposure = hq ? 1.25 : 1.1;
}
function postFirstFrameUpgrades(){
  setTimeout(()=>{ bloom.strength = highQuality ? 1.05 : 0.5; }, 300);
  setTimeout(()=>{ setQuality(true); }, 600);
  const dot = document.getElementById("loadDot"); if (dot) dot.style.display = "none";
}

const helpBox = document.getElementById("helpBox");
document.getElementById("btnFull").onclick = toggleFullscreen;
document.getElementById("btnBloom").onclick = ()=> bloom.strength = bloom.strength > 0 ? 0 : (highQuality?1.05:0.5);
document.getElementById("btnAuto").onclick = ()=> controls.autoRotate = !controls.autoRotate;
document.getElementById("btnQual").onclick = ()=> setQuality(!highQuality);
document.getElementById("btnHelp").onclick = ()=> helpBox.style.display = helpBox.style.display ? "" : "block";

addEventListener("keydown",(e)=>{
  const k = e.key.toLowerCase();
  if (k === "f") toggleFullscreen();
  if (k === "b") bloom.strength = bloom.strength > 0 ? 0 : (highQuality?1.05:0.5);
  if (k === "o") controls.autoRotate = !controls.autoRotate;
  if (k === "q") setQuality(!highQuality);
  if (k === "h") helpBox.style.display = helpBox.style.display ? "" : "block";
});

function toggleFullscreen(){
  const el = document.documentElement;
  if (!document.fullscreenElement) el.requestFullscreen?.();
  else document.exitFullscreen?.();
}

/* ----------------- Resize ----------------- */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
});

/* ----------------- Animate ----------------- */
const clock = new THREE.Clock();
renderer.setAnimationLoop(()=>{
  const dt = clock.getDelta();
  const t = clock.getElapsedTime();

  controls.update();
  updateSkyByTime();

  // RUDEBOY title idle motion
  if (textMesh){
    textMesh.rotation.y = Math.sin(t*0.6)*0.12;
  } else {
    placeholder.rotation.x += 0.01;
    placeholder.rotation.y += 0.02;
  }

  // nav spheres: spin + hover puff; labels face camera automatically (sprites)
  raycaster.setFromCamera(mouse, camera);
  const hits = new Set(raycaster.intersectObjects(navGroup.children, true).map(h=>{
    let g=h.object; while (g && g.parent !== navGroup) g = g.parent; return g;
  }));

  for (const g of navGroup.children){
    const hovered = hits.has(g);
    g.userData.hover = hovered;
    g.userData.t += dt;

    // sphere spin
    g.userData.sphere.rotation.y += (hovered ? 0.9 : 0.4) * dt;

    // scale puff on hover
    const target = hovered ? 1.12 : 1.0;
    g.scale.lerp(new THREE.Vector3(target,target,target), 0.15);

    // halo visibility tweak
    if (g.children[1]) g.children[1].material.opacity = hovered ? 0.16 : 0.08;

    // keep label upright (sprites already billboard, but prevent roll “wiggle”)
    g.userData.label.quaternion.copy(camera.quaternion);
  }

  // frog bubbles: drift and remove
  for (const spr of frogGroup.children){
    spr.userData.t += dt;
    spr.position.add(spr.userData.drift.clone().multiplyScalar(dt));
    spr.rotation.y += 0.1 * dt; // gentle spin
    if (spr.position.y < -10) spr.position.y = 10; // wrap around
  }

  composer.render();
});
</script>
</body>
</html>
